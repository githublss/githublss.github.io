<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>昨夜星辰的博客</title>
    <link>https://githublss.github.io/</link>
    <description>Recent content on 昨夜星辰的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Wed, 27 Nov 2019 21:52:30 +0800</lastBuildDate>
    
	<atom:link href="https://githublss.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://githublss.github.io/about/</link>
      <pubDate>Wed, 27 Nov 2019 21:52:30 +0800</pubDate>
      
      <guid>https://githublss.github.io/about/</guid>
      <description>在读研究生一名，对数据分析，可视化感兴趣，乐于分享
 写博客是对一个阶段学习的总结，也是一种知识的积累。不仅可以帮助自己，还可以帮到后面学习的人。多么希望本科的那个自己认识到这一点。
 希望自己也可以留下点什么东西。  我的github
我的知乎 csdn博客</description>
    </item>
    
    <item>
      <title>Taday</title>
      <link>https://githublss.github.io/post/taday/</link>
      <pubDate>Wed, 29 May 2019 21:41:51 +0800</pubDate>
      
      <guid>https://githublss.github.io/post/taday/</guid>
      <description>Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
Example 1:
 Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
 Example 2:
 Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://githublss.github.io/post/binary-search/</link>
      <pubDate>Wed, 29 May 2019 21:41:51 +0800</pubDate>
      
      <guid>https://githublss.github.io/post/binary-search/</guid>
      <description>Binary Search  Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.
 Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4  Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  Note:</description>
    </item>
    
    <item>
      <title>以数组存储的整数加一</title>
      <link>https://githublss.github.io/post/plus-one/</link>
      <pubDate>Wed, 29 May 2019 21:41:51 +0800</pubDate>
      
      <guid>https://githublss.github.io/post/plus-one/</guid>
      <description>Plus One  Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>Jump Game II</title>
      <link>https://githublss.github.io/post/blog/</link>
      <pubDate>Wed, 29 May 2019 21:07:01 +0800</pubDate>
      
      <guid>https://githublss.github.io/post/blog/</guid>
      <description>Jump Game II  Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.  Example:
Input: [2,3,1,1,4] Output: 2  Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/archives/</guid>
      <description>title: &amp;ldquo;归档&amp;rdquo; description: 菜鸟一只，数据分析，可视化 type: archives</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/merge-sorted-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/merge-sorted-array/</guid>
      <description>Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example:
Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6]  题意：将两个顺序排列的数组进行合并，假设nums1中可以容纳下来自于nums2的元素，最后nums1中为合并的结果。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/pascals-triangle-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/pascals-triangle-ii/</guid>
      <description> Pascal&amp;rsquo;s Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&amp;rsquo;s triangle.
Note that the row index starts from 0.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example: Input: 3 Output: [1,3,3,1]  Follow up:
Could you optimize your algorithm to use only O(k) extra space? 题意：此题与上一道生成三角形的题目的题意是类似的。但是这里只有能使用一个数组，而不能像之前一样来生成一个二维的数组 办法：由于要在一个数组上来进行操作，假如得出了第3层的数据，在计算第四层数据的时候：result[1]=result[0]+result[1],后面在计算result[2]=result[1]+result[2]的时候，result[1]已经被覆盖。 但是可以先计算出result[3]=result[3]+result[2],后面再计算result[2]=result[2]+result[1]的时候并不会影响对result[2]的计算，这样从后往前来计算。 class Solution { public: vector&amp;lt;int&amp;gt; getRow(int rowIndex) { vector&amp;lt;int&amp;gt; result(rowIndex+1, 1); //对数组进行初始化 if(rowIndex==0||rowIndex==1) return result; for(int i=2;i&amp;lt;=rowIndex;i++){ for(int j=i;j&amp;gt;1;j--){ result[j-1] = result[j-2] + result[j-1]; // 从后往前来对数组进行计算。 } } return result; } };  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/pascals-triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/pascals-triangle/</guid>
      <description> Pascal&amp;rsquo;s Triangle  Given a non-negative integer numRows, generate the first numRows of Pascal&amp;rsquo;s triangle.
In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]  题意：输入一个数，输出一个帕斯卡三角形。 解决办法：通过观测可以看出，每一行的开头和结尾都是1，从第三行开始，中间的数字都是由上面的两个数字相加得到的，可以先初始化一个矩阵，然后进行计算。递推公式是：result[i][j]=result[i-1][j-1]+result[i-1][j]
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; for(int i=1;i&amp;lt;=numRows;i++){ // 首先进行初始化 result.push_back(vector&amp;lt;int&amp;gt;(i,1)); } if(numRows&amp;gt;2){ for(int i=2;i&amp;lt;numRows;i++){ for(int j=1;j&amp;lt;i;j++){ result[i][j]=result[i-1][j-1]+result[i-1][j]; // 根据规律来生成三角形 } } } return result; } };   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/remove-duplicates-from-sorted-array-ii/</guid>
      <description>Remove Duplicates from Sorted Array II  Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/remove-duplicates-from-sorted-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/remove-duplicates-from-sorted-array/</guid>
      <description>Remove Duplicates from Sorted Array  Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/remove-element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/remove-element/</guid>
      <description>Remove Element  Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/sort-an-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/sort-an-array/</guid>
      <description>Sort an Array Given an array of integers nums, sort the array in ascending order.
Example 1: Input: nums = [5,2,3,1] Output: [1,2,3,5] Example 2: Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5]  题意：此题可以使用多种排序算法进行解答，算是数据结构中的基础题目。 方法：分别尝试使用简单选择排序、直接插入排序、快速排序方法来解决,但是由于简单选择排序和直接插入排序的时间复杂度比较高，没有通过所有的测试用例。
class Solution { public: vector&amp;lt;int&amp;gt; sortArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // selectSort(nums); // insertSort(nums); // quickSort(nums,0,nums.size()-1); // bubbleSort(nums); // heapSort(nums); mergeSort(nums); return nums; } // 简单选择排序 void selectSort(vector&amp;lt;int&amp;gt;&amp;amp; nums){ // 1.使用选择排序,由于时间复杂度为N方，测试用例通过率为9/10. int i,j; int selected,temp; for(i=0;i&amp;lt;nums.size()-1;i++){ selected = nums[i]; for(j=i;j&amp;lt;nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://githublss.github.io/post/two-sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://githublss.github.io/post/two-sum/</guid>
      <description>Two Sum  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
 Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].  solution: 自己首先想到的是暴力法，参考人家的，人家是遍历一次的过程中建立一个字典，提高了查询速度</description>
    </item>
    
  </channel>
</rss>